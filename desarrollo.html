<!DOCTYPE html>
<html lang="es" style="">

<head>
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta http-equiv="content-type" content="text/html; charset=utf-8">
	<meta name="Author" content="Equipo 5"><!--Autor-->
	<script src="media/js/jq.js" type="text/javascript"></script>
	<script src="media/js/m.js" type="text/javascript"></script>
	<script src="media/js/ui.js" type="text/javascript"></script>
	<link rel="stylesheet" href="media/css/ui.css" type="text/css">
	<link rel="stylesheet" href="media/css/portada.css" type="text/css">

</head>

<body style="">
	<br><br><br>
	<left>
	<h1>3. Desarrollo</h1> <br>
	<h3>PLANEACIÓN</h3>
	<h3>Modelo Cascada </h3>
	<h4>
		1.   Recolección y Análisis de Requisitos</h4>
Descripción: En esta fase, se recolectan y analizan los requisitos del sistema para entender qué debe 
hacer el software.
Objetivo: Definir claramente todas las necesidades y expectativas del cliente.
Resultado: Documentos de requisitos detallados que especifican las funcionalidades y restricciones 
del sistema.
	<h4>
		2.   Diseño del Sistema</h4>
Descripción:  Se  crea  la  arquitectura  del  sistema,  especificando  cómo  se  organizarán  los 
componentes y cómo interactuarán entre sí.
Objetivo: Crear un plan detallado que guíe la construcción del software.
Resultado: Diagramas y especificaciones técnicas que describen la estructura y el diseño del sistema.
		<br><br>
	<h4>
		3.   Implementación</h4>
Descripción: En esta fase, se escribe el código del software basado en los diseños especificados. 
Objetivo: Convertir los diseños en un sistema funcional.
Resultado: Código fuente que implementa todas las funcionalidades y requisitos definidos.
	
	
	<h4>
		4.   Pruebas</h4>
Descripción:  Se  verifica  que  el  software  funcione  correctamente  y  cumpla  con  los  requisitos 
especificados.
Objetivo: Identificar y corregir errores en el software.
Resultado: Un sistema probado que cumple con los estándares de calidad y funcionalidad.
	

	<h4>
		5.   Despliegue</h4>
Descripción: El software se entrega y se instala en el entorno de producción para su uso por los 
usuarios finales.
Objetivo: Poner el sistema en manos de los usuarios. 
Resultado: Software operando en el entorno del cliente.
	

	<h4>6.   Mantenimiento</h4>
		
Descripción: Se realiza el mantenimiento del software para corregir errores que no se detectaron 
en las pruebas, mejorar la funcionalidad y adaptarse a los cambios en el entorno.
Objetivo: Asegurar que el sistema siga funcionando correctamente y se mantenga relevante a lo 
largo del tiempo.
Resultado: Actualizaciones y mejoras continuas del software.
	

	<h5>
		Características Clave del Modelo de Cascada</h5>
Secuencial: Cada fase debe completarse antes de comenzar la siguiente. No se vuelve a fases 
anteriores.<br>
Documentación  Extensiva:  Cada  fase  produce  documentación  que  se  utiliza  como  guía  en  la 
siguiente fase.<br>
Riesgo de Rigidez: Dificulta la respuesta rápida a cambios en los requisitos una vez que el proyecto 
ha avanzado.
	


	<h3>Requerimientos y optimización</h3>
	<h4>
		Importancia de la Recopilación de Requisitos</h4>
Clara Definición de Objetivos: Asegura que el equipo de desarrollo y los stakeholders tengan una 
visión clara y compartida de lo que se espera del producto.<br>
Reducción de Riesgos: Identificar y entender los requisitos desde el principio ayuda a evitar cambios 
costosos y retrasos más adelante.<br>
<h4>Técnicas para la Recopilación de Requisitos</h4>
Entrevistas:   Hablar   directamente   con   los   stakeholders   para   entender   sus   necesidades   y 
expectativas.<br>
Cuestionarios y Encuestas: Herramientas útiles para recopilar información de un gran número de 
personas de manera eficiente. <br>
Talleres de Requisitos: Reuniones colaborativas donde los stakeholders y el equipo de desarrollo 
trabajan juntos para definir los requisitos.<br>
Análisis de Documentación: Revisar documentos existentes que puedan proporcionar contexto y 
detalles sobre los requisitos del sistema.<br>
Creación de Personas y Escenarios: Definir perfiles de usuarios y situaciones para entender mejor 
cómo se utilizará el producto.<br>
<h4>Optimización del Proceso de Recopilación de Requisitos</h4>
Participación Continua de los Stakeholders: Mantén a los stakeholders involucrados a lo largo del 
proyecto para asegurarte de que los requisitos sigan alineados con sus necesidades.<br>
Documentación Clara y Concisa: Es fundamental tener documentos de requisitos bien estructurados 
y fáciles de entender.<br>
Uso de Prototipos: Crear prototipos tempranos puede ayudar a validar los requisitos y obtener 
feedback rápidamente.<br>
Priorizar Requisitos: No todos los requisitos tienen el mismo valor. Usar técnicas como el análisis 
MOSCOW (Must have, Should have, Could have, Won't have) para priorizar.<br>
Revisiones Regulares: Revisar y ajustar los requisitos regularmente para reflejar cambios en las 
necesidades y el contexto del proyecto.
	

	
	<h3>Gestión de proyecto </h3>
	
	<h4>Planificación del Proyecto:</h4>
		<ul>
			<li>Definición de Objetivos: Clarificar lo que el proyecto debe lograr.</li>
			<li>Estructura de Desglose del Trabajo (EDT): Dividir el proyecto en tareas más manejables.</li>
			<li>Estimación de Costos y Tiempo: Utilizar técnicas como PERT o COCOMO para estimar tiempo y recursos necesarios.</li>
			<li>Planificación del Calendario: Crear un cronograma que detalle cuándo se deben completar las tareas. Herramientas como diagramas de Gantt son útiles aquí.</li>
		  </ul>
		<br><img src="media/img/naipe1.gif" alt="">
	
	<h4>Gestión de Riesgos: </h4>
		<ul>
			<li>Identificación de Riesgos: Determinar posibles problemas que podrían afectar el proyecto.</li>
			<li>Análisis de Riesgos: Evaluar la probabilidad y el impacto de cada riesgo</li>
			<li>Planificación de Respuestas a los Riesgos: Desarrollar estrategias para mitigar o manejar
				estos riesgos.</li>
			<li>Monitoreo de Riesgos: Supervisar continuamente los riesgos a lo largo del proyecto.</li>
			<li>Control del Progreso: Utilizar métricas como el valor ganado (Earned Value) para medir el
				avance.</li>
			<li>Gestión de Cambios: Implementar un proceso para manejar solicitudes de cambio y
				asegurarse de que se evalúen adecuadamente.</li>
			<li>Revisiones y Auditorías: Realizar revisiones periódicas para garantizar que el proyecto se
				mantiene en el buen camino	</li>
		</ul>


	<h4>Verificación y Validación del Software</h4>
	<ul>
		<li>Verificación: Proceso de evaluar productos intermedios para asegurar que están
			construidos correctamente (¿Estamos construyendo el producto correctamente?).</li>
		<li>Validación: Proceso de evaluar el producto final para asegurar que cumple con las
			necesidades del cliente (¿Estamos construyendo el producto correcto?).</li>
		<li>Revisiones y Auditorías: Evaluaciones sistemáticas de productos intermedios.</li>
		<li>Pruebas Unitarias: Pruebas de pequeñas unidades de código de manera aislada.</li>
		<li>Análisis Estático: Herramientas que analizan el código sin ejecutarlo para detectar errores</li>
		<li>Pruebas de Sistema: Pruebas del sistema completo para asegurar que cumple con los
			requisitos.</li>
		<li>Pruebas de Aceptación del Usuario: Pruebas realizadas por los usuarios finales para asegurar
			que el software cumple con sus necesidades</li>
		<li>Pruebas de Aceptación del Usuario: Pruebas realizadas por los usuarios finales para asegurar
			que el software cumple con sus necesidades</li>
		<li>Pruebas de Integración: Verificación de que los módulos de software funcionan
			correctamente juntos.</li> <br>
	</ul>
	<h3>CICLO DE VIDA DEL SOFTWARE</h3>
	<h3>Inducción para un equipo no especializado (cliente) </h3>
	El desarrollo de software es como construir y mantener una casa. Al principio, la casa es solo un
diseño en papel. Luego, con el tiempo, se va construyendo, adaptando y mejorando. A lo largo de
su vida, se realizarán arreglos y cambios para mantenerla cómoda, segura y en buen estado.
<ol>
	<li>Diseño Inicial: Al empezar un proyecto de software, se necesita tener una idea clara de lo
		que se quiere hacer, al igual que cuando se planea una casa. Pero en lugar de hacer un
		diseño que nunca se puede cambiar, el diseño del software se hace pensando en que se
		podrá modificar y mejorar con el tiempo.</li>
	<li>Escribir el Código Claro y con Propósito: En esta fase, los desarrolladores escriben el
		“código”, es decir, las instrucciones que le dicen a la computadora qué hacer. La idea aquí
		es que estas instrucciones sean tan fáciles de entender como una receta de cocina clara y
		simple, para que cualquiera que lea el código sepa exactamente qué hace cada parte</li>
	<li>Pruebas y Mejoras Continuas: Una vez que el código está funcionando, se hacen pruebas
		para asegurarse de que todo esté bien y que no haya errores. Estas pruebas se repiten
		regularmente, como revisar cada cierto tiempo si las luces de la casa funcionan o si las
		puertas están en buen estado. Además, durante el ciclo de vida del software, el código se
		ajusta y mejora para que sea más claro y siga cumpliendo con lo que necesita hacer.</li>
	<li>Mantenimiento y Evolución: A medida que el software se usa, pueden surgir nuevas
		necesidades. Quizá los usuarios quieran que haga cosas nuevas o que funcione de una forma
		diferente. Aquí, el software se ajusta y adapta, como cuando haces renovaciones en una
		casa para mejorarla o hacerla más moderna.</li>
	<li>Documentación Clara: En lugar de escribir un montón de documentos para explicar cada
		detalle del software, se trata de que el código sea lo suficientemente claro por sí mismo. Sin
		embargo, como una casa puede necesitar ciertos planos o instrucciones específicas (como
		el uso de un sistema especial de calefacción), el software también tiene partes clave donde
		se da una explicación extra para que cualquiera pueda entenderlas.</li>
</ol>
	
	<h3>Proceso continuo de creación</h3>
	El ciclo de vida del software puede entenderse como un proceso continuo de creación, mejora y
	mantenimiento del código para garantizar que siga siendo claro, funcional y fácil de modificar. El
	ciclo de vida no se trata solo de completar las etapas de desarrollo tradicionales (planificación,
	diseño, implementación, pruebas y mantenimiento), sino de adoptar un enfoque de desarrollo ágil
	y artesanal. Los aspectos clave para su implementación son: 
	<ol>
		<li>Diseño Inicial: En Código Limpio, el diseño inicial no significa hacer un diseño exhaustivo que
			no se pueda cambiar, sino crear una estructura básica que sea fácil de extender. Se aplica
			el principio de "hacerlo bien desde el principio", es decir, escribir código que sea claro y
			comprensible desde la primera versión.</li>
		<li>Codificación Clara y con Propósito: Durante la fase de implementación, el enfoque está en
			escribir código que sea fácil de entender y mantener. Esto implica usar nombres
			significativos, crear funciones pequeñas y específicas, y asegurarse de que el código sea lo
			más simple posible para cumplir con su propósito.
			</li>
		<li>Pruebas Automatizadas y Refactorización Continua: Una parte esencial del ciclo de vida en
			el contexto de Código Limpio es la importancia de las pruebas automáticas, que permiten
			verificar rápidamente que el código funciona como se espera. La refactorización se hace de
			forma continua, no como una fase aislada, para mejorar el diseño del código sin alterar su
			funcionalidad. El proceso de refactorización permite mantener el código limpio y fácil de
			cambiar en cada fase del ciclo de vida.</li>
		<li>Mantenimiento y Evolución: En un enfoque de desarrollo ágil, el software se mejora
			continuamente según las necesidades del cliente o del equipo. Esto implica realizar cambios
			en el código sin que este se vuelva confuso o difícil de entender. Las prácticas de código
			limpio aseguran que el software siga siendo mantenible y escalable a lo largo del tiempo</li>
		<li>Mínima pero Clara: En lugar de documentar cada detalle del código, el enfoque de Código
			Limpio sugiere que el propio código cuente la historia. La documentación se limita a lo
			esencial y se enfoca en aspectos que realmente necesiten explicaciones adicionales.</li>
	</ol>
	<h3>Proceso automatizado </h3>
	<h4>Pipeline de Despliegue </h4>
	El pipeline de despliegue es el corazón de la entrega continua. Es un conjunto automatizado de
pasos que toma el código desde su desarrollo inicial hasta su despliegue en producción. Los
componentes clave incluyen:<br><br>
Compilación: Transformar el código fuente en un artefacto ejecutable.<br><br>
Pruebas Automatizadas: Ejecución de pruebas unitarias, pruebas de integración y pruebas de
sistema para asegurar que el código funciona correctamente.
	<h4>Integración Continua </h4>
	La integración continua es un proceso donde los desarrolladores integran frecuentemente su
trabajo en el repositorio principal, seguido de compilaciones automáticas y pruebas. Este proceso
asegura que los cambios en el código son continuamente verificados.<br><br>
Control de Versiones: Uso de sistemas de control de versiones para administrar y rastrear cambios
en el código.<br><br>
Compilación Automática: Cada integración en el repositorio principal desencadena una compilación
automática del código.<br><br>
Pruebas Inmediatas: Ejecución de pruebas automáticas inmediatamente después de cada
compilación.
	<h4>Automatización de Pruebas</h4>
	Las pruebas automatizadas son esenciales para detectar errores rápidamente. Incluyen:<br><br>
	Pruebas Unitarias: Pruebas de pequeñas unidades de código de forma aislada.<br><br>
	Pruebas de Integración: Verificación de que diferentes módulos de la aplicación funcionan juntos
	correctamente.<br><br>
	Pruebas de Sistema: Pruebas de la aplicación completa en un entorno que simula el entorno de
	producción.
	
	<h4>Infraestructura como Código (IaC)</h4>
	La infraestructura como código implica gestionar y aprovisionar los entornos de TI mediante código.
Esto asegura que los entornos son reproducibles y consistentes.<br><br>
Configuración Automatizada: Uso de herramientas como Terraform o Ansible para automatizar la
configuración del entorno.<br><br>
Provisionamiento Dinámico: Crear y destruir entornos bajo demanda, asegurando un uso eficiente
de los recursos.<br><br>
	<h4>Monitoreo y Feedback</h4>
	El monitoreo constante del sistema en producción y el feedback continuo permite a los equipos
responder rápidamente a los problemas.<br><br>
Monitoreo de Aplicaciones: Uso de herramientas de monitoreo para rastrear el rendimiento y los
errores en tiempo real.<br><br>
Alertas Automatizadas: Configuración de alertas para notificar a los equipos de cualquier problema
emergente.<br><br>
Feedback del Usuario: Recopilación de feedback del usuario para guiar futuras mejoras y
correcciones.<br><br>
<h3>PROCESO DE CALIDAD</h3>
<h3>Prácticas y decisiones del desarrollo </h3>
<h4>Claridad y legibilidad del código</h4>
Uno de los puntos más importantes es que el código debe ser fácil de leer y entender. Si el código
es claro, otros desarrolladores (o incluso el mismo autor en el futuro) podrán comprenderlo
fácilmente y realizar mejoras o correcciones. Esto reduce el tiempo que se necesita para entender
y trabajar en el software, lo que mejora su calidad y facilita su mantenimiento.
<h4>Practicidad y enfoque </h4>
El código debe hacer solo lo que necesita y nada más. Es decir, cada función, clase o componente
del software debe tener un propósito claro y no mezclar tareas. Esto hace que el código sea más
fácil de mantener y reduce la posibilidad de errores.
<h4>Pruebas automáticas </h4>
La calidad del software también depende de qué tan bien esté probado. La importancia de las
pruebas automáticas (pruebas de software que se ejecutan automáticamente para verificar que el
código funciona como se espera). Estas pruebas permiten a los desarrolladores hacer cambios en el
código con confianza, ya que pueden detectar rápidamente si algo deja de funcionar. Esto hace que
el ciclo de vida del software sea más estable y reduce el riesgo de problemas inesperados.
<h4>Refactorización continúa</h4>
La refactorización es el proceso de mejorar el código sin cambiar lo que hace. Refactorizar
regularmente es esencial para mantener el código limpio y de alta calidad. Esto significa que los
desarrolladores no esperan a que el código se vuelva complicado o desordenado, sino que
constantemente lo ajustan para que siga siendo claro y manejable.
<h4>Responsabilidad en el equipo de desarrollo</h4>
La calidad del ciclo de vida del software también depende de la responsabilidad de los
desarrolladores y de una buena cultura de equipo. Todos en el equipo deben comprometerse a
escribir código limpio y seguir buenas prácticas. Cada miembro del equipo debe ser responsable de
la calidad de su propio código y estar dispuesto a colaborar para mejorar el software en conjunto.
<h4>Documentación mínima pero útil</h4>
La documentación es importante, pero el mejor código es aquel que se explica a sí mismo sin
necesidad de mucha documentación adicional. La documentación debe enfocarse en los aspectos
críticos y en lo que no es evidente por el propio código, evitando la sobrecarga de información
innecesaria.
<h4>Adherencia a principios de diseño</h4>
Principios de diseño, como los principios SOLID, que ayudan a que el software sea modular y flexible.
Estos principios permiten que el software pueda adaptarse a cambios sin requerir grandes
reestructuraciones, lo cual es esencial para un ciclo de vida de alta calidad.

<h3>Certificación de la calidad e introducción al mercado</h3>
<h4>Estandarización de Procesos y Mejores Prácticas</h4>
Uno de los enfoques del libro es estandarizar las prácticas de desarrollo. Al seguir un proceso
definido y maduro, como los modelos en cascada, ágil o incremental, los equipos pueden reducir
la incertidumbre y minimizar los errores comunes. Esto lleva a productos más estables y de alta
calidad, lo cual es clave para el éxito en un mercado competitivo donde los errores pueden
arruinar la reputación de una empresa.
<h4>Mejor Administración del Tiempo y los Recursos</h4>
La gestión de proyectos es crucial en el desarrollo de software, y el libro enseña cómo manejar
recursos, estimar costos y plazos, y evaluar riesgos. Con una mejor administración, los equipos
pueden cumplir con los plazos de entrega, lo que impacta directamente en la satisfacción del
cliente y en la capacidad de competir en el mercado. Un software de calidad, entregado a tiempo y
dentro del presupuesto, es un factor de éxito fundamental.
<h4>Recopilación y Gestión de Requerimientos</h4>
Pressman dedica secciones a la obtención de requerimientos efectivos, lo que ayuda a alinear el
software con las necesidades del cliente. Esto es importante porque un producto que satisface
realmente las necesidades del usuario final tiene una mejor acogida en el mercado. Además, al
comprender los requisitos desde el principio, los desarrolladores pueden evitar costosos cambios y
correcciones más adelante.
<h4>Diseño Escalable y Modular</h4>
Al fomentar un diseño modular y escalable, el libro ayuda a los desarrolladores a crear software
que puede evolucionar con el tiempo sin requerir una reescritura completa. Esta capacidad de
adaptación es valiosa, ya que las necesidades del mercado cambian y un software flexible puede
actualizarse y ampliarse para mantenerse relevante, reduciendo el costo y el tiempo de desarrollo
para futuras versiones.
<h4>Control de Calidad Estricto y Reducción de Errores</h4>
Las prácticas de control de calidad (QA) descritas en el libro, incluyendo revisiones de código y
pruebas exhaustivas, ayudan a identificar y corregir errores temprano en el proceso. Un software
con menos errores genera una mejor experiencia de usuario, lo que mejora la reputación y reduce
los costos de soporte técnico. Esto es clave para el éxito en un mercado donde la fiabilidad del
producto puede hacer la diferencia entre ganar o perder clientes
<h4>Adopción de Tecnologías Modernas y DevOps</h4>
En ediciones recientes, el libro cubre metodologías como DevOps, que promueven una integración
y entrega continua. Esto permite a las empresas lanzar versiones mejoradas y actualizaciones
constantes, respondiendo rápidamente a las necesidades del mercado. Esta agilidad proporciona
una ventaja competitiva y permite que el software evolucione en sincronía con las demandas de
los usuarios
<h4>Enfoque en Seguridad y Prácticas Éticas</h4>
Con el aumento de la preocupación por la seguridad, el libro también aborda cómo integrar
buenas prácticas de seguridad durante el desarrollo. Un software seguro no solo protege la
información de los usuarios, sino que también construye confianza en la marca, algo esencial para
que un producto prospere en el mercado. Los usuarios y las empresas suelen preferir software con
un historial de seguridad y calidad comprobada.
<h4>Mejora de la Productividad y Satisfacción del Equipo</h4>
La claridad en los procesos y roles que propone el libro ayuda a que los equipos de desarrollo se
mantengan enfocados y organizados, lo que incrementa su productividad y satisfacción laboral.
Los equipos bien organizados y motivados producen software de mayor calidad, algo que es
evidente para los usuarios finales y contribuye al éxito en el mercado.
<br><br><br>
</left>			
</body>

</html>
