<!DOCTYPE html>
<html lang="es" style="">

<head>
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta http-equiv="content-type" content="text/html; charset=utf-8">
	<meta name="Author" content="Equipo 2"><!--Autor-->
	<script src="media/js/jq.js" type="text/javascript"></script>
	<script src="media/js/m.js" type="text/javascript"></script>
	<script src="media/js/ui.js" type="text/javascript"></script>
	<link rel="stylesheet" href="media/css/ui.css" type="text/css">
	<link rel="stylesheet" href="media/css/portada.css" type="text/css">

</head>

<body style="">
	<br><br><br>
	<h1>3. Desarrollo</h1> <br>
	<h3>PLANEACIÓN</h3>
	<h3>Modelo Cascada </h3>
	<h4>
		1.   Recolección y Análisis de Requisitos</h4>
Descripción: En esta fase, se recolectan y analizan los requisitos del sistema para entender qué debe 
hacer el software.
Objetivo: Definir claramente todas las necesidades y expectativas del cliente.
Resultado: Documentos de requisitos detallados que especifican las funcionalidades y restricciones 
del sistema.
	
	<h4>
		2.   Diseño del Sistema</h4>
Descripción:  Se  crea  la  arquitectura  del  sistema,  especificando  cómo  se  organizarán  los 
componentes y cómo interactuarán entre sí.
Objetivo: Crear un plan detallado que guíe la construcción del software.
Resultado: Diagramas y especificaciones técnicas que describen la estructura y el diseño del sistema.
		<br><br>
	
	<h4>
		3.   Implementación</h4>
Descripción: En esta fase, se escribe el código del software basado en los diseños especificados. 
Objetivo: Convertir los diseños en un sistema funcional.
Resultado: Código fuente que implementa todas las funcionalidades y requisitos definidos.
	
	
	<h4>
		4.   Pruebas</h4>
Descripción:  Se  verifica  que  el  software  funcione  correctamente  y  cumpla  con  los  requisitos 
especificados.
Objetivo: Identificar y corregir errores en el software.
Resultado: Un sistema probado que cumple con los estándares de calidad y funcionalidad.
	

	<h4>
		5.   Despliegue</h4>
Descripción: El software se entrega y se instala en el entorno de producción para su uso por los 
usuarios finales.
Objetivo: Poner el sistema en manos de los usuarios. 
Resultado: Software operando en el entorno del cliente.
	

	<h4>6.   Mantenimiento</h4>
		
Descripción: Se realiza el mantenimiento del software para corregir errores que no se detectaron 
en las pruebas, mejorar la funcionalidad y adaptarse a los cambios en el entorno.
Objetivo: Asegurar que el sistema siga funcionando correctamente y se mantenga relevante a lo 
largo del tiempo.
Resultado: Actualizaciones y mejoras continuas del software.
	

	<h5>
		Características Clave del Modelo de Cascada</h5>
Secuencial: Cada fase debe completarse antes de comenzar la siguiente. No se vuelve a fases 
anteriores.<br>
Documentación  Extensiva:  Cada  fase  produce  documentación  que  se  utiliza  como  guía  en  la 
siguiente fase.<br>
Riesgo de Rigidez: Dificulta la respuesta rápida a cambios en los requisitos una vez que el proyecto 
ha avanzado.
	


	<h3>Requerimientos y optimización</h3>
	<h4>
		Importancia de la Recopilación de Requisitos</h4>
Clara Definición de Objetivos: Asegura que el equipo de desarrollo y los stakeholders tengan una 
visión clara y compartida de lo que se espera del producto.<br>
Reducción de Riesgos: Identificar y entender los requisitos desde el principio ayuda a evitar cambios 
costosos y retrasos más adelante.<br>
<h4>Técnicas para la Recopilación de Requisitos</h4>
Entrevistas:   Hablar   directamente   con   los   stakeholders   para   entender   sus   necesidades   y 
expectativas.<br>
Cuestionarios y Encuestas: Herramientas útiles para recopilar información de un gran número de 
personas de manera eficiente. <br>
Talleres de Requisitos: Reuniones colaborativas donde los stakeholders y el equipo de desarrollo 
trabajan juntos para definir los requisitos.<br>
Análisis de Documentación: Revisar documentos existentes que puedan proporcionar contexto y 
detalles sobre los requisitos del sistema.<br>
Creación de Personas y Escenarios: Definir perfiles de usuarios y situaciones para entender mejor 
cómo se utilizará el producto.<br>
<h4>Optimización del Proceso de Recopilación de Requisitos</h4>
Participación Continua de los Stakeholders: Mantén a los stakeholders involucrados a lo largo del 
proyecto para asegurarte de que los requisitos sigan alineados con sus necesidades.<br>
Documentación Clara y Concisa: Es fundamental tener documentos de requisitos bien estructurados 
y fáciles de entender.<br>
Uso de Prototipos: Crear prototipos tempranos puede ayudar a validar los requisitos y obtener 
feedback rápidamente.<br>
Priorizar Requisitos: No todos los requisitos tienen el mismo valor. Usar técnicas como el análisis 
MOSCOW (Must have, Should have, Could have, Won't have) para priorizar.<br>
Revisiones Regulares: Revisar y ajustar los requisitos regularmente para reflejar cambios en las 
necesidades y el contexto del proyecto.
	

	
	<h3>Gestión de proyecto </h3>
	
	<h4>Planificación del Proyecto:</h4>
		<ul>
			<li>Definición de Objetivos: Clarificar lo que el proyecto debe lograr.</li>
			<li>Estructura de Desglose del Trabajo (EDT): Dividir el proyecto en tareas más manejables.</li>
			<li>Estimación de Costos y Tiempo: Utilizar técnicas como PERT o COCOMO para estimar tiempo y recursos necesarios.</li>
			<li>Planificación del Calendario: Crear un cronograma que detalle cuándo se deben completar las tareas. Herramientas como diagramas de Gantt son útiles aquí.</li>
		  </ul>
		<br><img src="media/img/naipe1.gif" alt="">
	
	<h4>Gestión de Riesgos: </h4>
		<ul>
			<li>Identificación de Riesgos: Determinar posibles problemas que podrían afectar el proyecto.</li>
			<li>Análisis de Riesgos: Evaluar la probabilidad y el impacto de cada riesgo</li>
			<li>Planificación de Respuestas a los Riesgos: Desarrollar estrategias para mitigar o manejar
				estos riesgos.</li>
			<li>Monitoreo de Riesgos: Supervisar continuamente los riesgos a lo largo del proyecto.</li>
			<li>Control del Progreso: Utilizar métricas como el valor ganado (Earned Value) para medir el
				avance.</li>
			<li>Gestión de Cambios: Implementar un proceso para manejar solicitudes de cambio y
				asegurarse de que se evalúen adecuadamente.</li>
			<li>Revisiones y Auditorías: Realizar revisiones periódicas para garantizar que el proyecto se
				mantiene en el buen camino	</li>
		</ul>


	<h4>Verificación y Validación del Software</h4>
	<ul>
		<li>Verificación: Proceso de evaluar productos intermedios para asegurar que están
			construidos correctamente (¿Estamos construyendo el producto correctamente?).</li>
		<li>Validación: Proceso de evaluar el producto final para asegurar que cumple con las
			necesidades del cliente (¿Estamos construyendo el producto correcto?).</li>
		<li>Revisiones y Auditorías: Evaluaciones sistemáticas de productos intermedios.</li>
		<li>Pruebas Unitarias: Pruebas de pequeñas unidades de código de manera aislada.</li>
		<li>Análisis Estático: Herramientas que analizan el código sin ejecutarlo para detectar errores</li>
		<li>Pruebas de Sistema: Pruebas del sistema completo para asegurar que cumple con los
			requisitos.</li>
		<li>Pruebas de Aceptación del Usuario: Pruebas realizadas por los usuarios finales para asegurar
			que el software cumple con sus necesidades</li>
		<li>Pruebas de Aceptación del Usuario: Pruebas realizadas por los usuarios finales para asegurar
			que el software cumple con sus necesidades</li>
		<li>Pruebas de Integración: Verificación de que los módulos de software funcionan
			correctamente juntos.</li> <br>
	</ul>
	<h3>CICLO DE VIDA DEL SOFTWARE</h3>
	<h3>Inducción para un equipo no especializado (cliente) </h3>
	El desarrollo de software es como construir y mantener una casa. Al principio, la casa es solo un
diseño en papel. Luego, con el tiempo, se va construyendo, adaptando y mejorando. A lo largo de
su vida, se realizarán arreglos y cambios para mantenerla cómoda, segura y en buen estado.
<ol>
	<li>Diseño Inicial: Al empezar un proyecto de software, se necesita tener una idea clara de lo
		que se quiere hacer, al igual que cuando se planea una casa. Pero en lugar de hacer un
		diseño que nunca se puede cambiar, el diseño del software se hace pensando en que se
		podrá modificar y mejorar con el tiempo.</li>
	<li>Escribir el Código Claro y con Propósito: En esta fase, los desarrolladores escriben el
		“código”, es decir, las instrucciones que le dicen a la computadora qué hacer. La idea aquí
		es que estas instrucciones sean tan fáciles de entender como una receta de cocina clara y
		simple, para que cualquiera que lea el código sepa exactamente qué hace cada parte</li>
	<li>Pruebas y Mejoras Continuas: Una vez que el código está funcionando, se hacen pruebas
		para asegurarse de que todo esté bien y que no haya errores. Estas pruebas se repiten
		regularmente, como revisar cada cierto tiempo si las luces de la casa funcionan o si las
		puertas están en buen estado. Además, durante el ciclo de vida del software, el código se
		ajusta y mejora para que sea más claro y siga cumpliendo con lo que necesita hacer.</li>
	<li>Mantenimiento y Evolución: A medida que el software se usa, pueden surgir nuevas
		necesidades. Quizá los usuarios quieran que haga cosas nuevas o que funcione de una forma
		diferente. Aquí, el software se ajusta y adapta, como cuando haces renovaciones en una
		casa para mejorarla o hacerla más moderna.</li>
	<li>Documentación Clara: En lugar de escribir un montón de documentos para explicar cada
		detalle del software, se trata de que el código sea lo suficientemente claro por sí mismo. Sin
		embargo, como una casa puede necesitar ciertos planos o instrucciones específicas (como
		el uso de un sistema especial de calefacción), el software también tiene partes clave donde
		se da una explicación extra para que cualquiera pueda entenderlas.</li>
</ol>
	
	<h3>Proceso continuo de creación</h3>
	El ciclo de vida del software puede entenderse como un proceso continuo de creación, mejora y
	mantenimiento del código para garantizar que siga siendo claro, funcional y fácil de modificar. El
	ciclo de vida no se trata solo de completar las etapas de desarrollo tradicionales (planificación,
	diseño, implementación, pruebas y mantenimiento), sino de adoptar un enfoque de desarrollo ágil
	y artesanal. Los aspectos clave para su implementación son: 
	<ol>
		<li>Diseño Inicial: En Código Limpio, el diseño inicial no significa hacer un diseño exhaustivo que
			no se pueda cambiar, sino crear una estructura básica que sea fácil de extender. Se aplica
			el principio de "hacerlo bien desde el principio", es decir, escribir código que sea claro y
			comprensible desde la primera versión.</li>
		<li>Codificación Clara y con Propósito: Durante la fase de implementación, el enfoque está en
			escribir código que sea fácil de entender y mantener. Esto implica usar nombres
			significativos, crear funciones pequeñas y específicas, y asegurarse de que el código sea lo
			más simple posible para cumplir con su propósito.
			</li>
		<li>Pruebas Automatizadas y Refactorización Continua: Una parte esencial del ciclo de vida en
			el contexto de Código Limpio es la importancia de las pruebas automáticas, que permiten
			verificar rápidamente que el código funciona como se espera. La refactorización se hace de
			forma continua, no como una fase aislada, para mejorar el diseño del código sin alterar su
			funcionalidad. El proceso de refactorización permite mantener el código limpio y fácil de
			cambiar en cada fase del ciclo de vida.</li>
		<li>Mantenimiento y Evolución: En un enfoque de desarrollo ágil, el software se mejora
			continuamente según las necesidades del cliente o del equipo. Esto implica realizar cambios
			en el código sin que este se vuelva confuso o difícil de entender. Las prácticas de código
			limpio aseguran que el software siga siendo mantenible y escalable a lo largo del tiempo</li>
		<li>Mínima pero Clara: En lugar de documentar cada detalle del código, el enfoque de Código
			Limpio sugiere que el propio código cuente la historia. La documentación se limita a lo
			esencial y se enfoca en aspectos que realmente necesiten explicaciones adicionales.</li>
	</ol>
	<h3>Proceso automatizado </h3>
	<h5>
		<i>Definición: </i><br>
		Decimos que dos eventos, A y B, son independientes cuando la probabilidad de que ocurra el evento A no cambia, independientemente de si el evento B ocurre o  
		no. En otras palabras, A y B son eventos independientes si la probabilidad condicional de que ocurra A dado que ocurrió B es igual a la probabilidad original 
		de que ocurra A. Esto se expresa matemáticamente como:
	</h5>
	<img src="media/img/img5.png" alt="">
	<h5>
		<br> O de manera equivalente, cuando la probabilidad de que ambos eventos A y B ocurran juntos es igual al producto de las probabilidades individuales de A y B es decir:
	</h5>
	<img src="media/img/img6.png" alt="">
	<h4 align="center"><br><br>Independencia de más de dos sucesos</h4>
	<h5>
		Sean A1, A2 ... An , sucesos de cierto espacio muestral; diremos que ellos son mutuamente independientes (o simplemente, independientes) cuando para cualquier 
		grupo de sucesos diferentes Ai, Aj ... Am se cumple que:
	</h5>
	<img src="media/img/img7.png" alt="">
	<h5>
		<br>Para que n sucesos sean independientes no es suficiente que sean independientes dos a dos, es decir, que dos cualesquiera de ellos sean independientes. [13] <br><br>
		En muchos problemas prácticos, nos encontramos con pruebas que son mutuamente independientes, lo que significa que el resultado de una prueba no afecta el resultado 
		de otra. Para comprender mejor este concepto, consideremos un experimento que consiste en <i>n</i> pruebas independientes. <i>“Esto se cumple si y sólo si: el espacio muestral 
		S es el producto Cartesiano de n conjuntos S1, S2, ..., Sn y la probabilidad de que ocurra un evento de un solo elemento A&#8834;S es el producto de las probabilidades 
		de ocurrencia de los eventos correspondientes de un solo elemento, Ai&#8834;Si, i = 1, 2, ..., n. En otras palabras, p(A)=p1(A1)p2(A2). . .pn(An), donde A&#8834;S, Ai&#8834;Si, y A, 
		Ai, ..., An son eventos de un solo elemento.” [10] </i><br><br>
		De acuerdo con lo anterior, el espacio muestral de un experimento que consiste en n pruebas independientes se compone de n factores. Por lo tanto, las probabilidades 
		de los eventos de un solo elemento se asignan de una manera particular, lo que facilita el cálculo de diversas posibilidades. Aunque en la mayor parte de las aplicaciones 
		no necesitamos verificar todas las condiciones, puesto que generalmente suponemos la independencia con base en lo que sabemos acerca del experimento. <br><br>
		Es importante destacar que si A y B son eventos independientes, se cumple la siguiente relación:
	</h5>
	<img src="media/img/img8.png" alt="">
	<h5>
		<br>En otras palabras, cuando A y B son independientes, la probabilidad de que ocurra A no se ve afectada por la ocurrencia de B. <i> “Saber que B ha ocurrido no modifica 
		la probabilidad de que A ocurra. De manera equivalente, podemos afirmar que p(A|B) = p(B) si y sólo si A y B son independientes.”</i> [10] <br><br>
		Comúnmente las definiciones de independencia y mutua exclusividad se confunden, en gran parte debido a que en la comunicación cotidiana, la palabra "independiente" 
		a menudo se interpreta como que dos eventos no pueden ocurrir simultáneamente. Esto nos lleva a la conclusión de que dos eventos son mutuamente excluyentes cuando no 
		pueden suceder al mismo tiempo, tal como se establece en la siguiente definición: <i> "A y B son mutuamente excluyentes si y sólo si A&#8745;B=&#8709;"</i> [10]. <br><br>
		Al comparar esta definición con la de independencia, resulta evidente que son conceptos completamente diferentes. <br><br>
		También existe la independencia de tres eventos, la cual señala que A,B,C  son independientes, si sólo si:
	</h5>
	<img src="media/img/img9.png" alt="">
	<h5>
		<br>Para este caso en el que se presentan tres eventos, cabe la posibilidad de que las tres primeras condiciones anteriores no lleguen a implicar a la cuarta y viceversa.
		<br><br><br>
	</h5>
	<h3>3.4 Teorema de Bayes</h3>
	<h5>
		Quizás el teorema más importante de la Teoría de la Probabilidad es el denominado Teorema de Bayes, ya que él constituye la base de toda una ciencia: 
		la Inferencia Estadística. <br><br>
		Sea A un suceso y B1, B2 ... Bn una serie de sucesos disyuntos tales la ocurrencia de A va necesariamente acompañada por la ocurrencia de uno de ellos. <br><br>
		Se conocen las probabilidades de los Bi como también las probabilidades condicionales de A dado cada uno de los Bi. Sabiendo ahora que A ocurrió, se desea 
		calcular la probabilidad de cada Bi dada esta información. [13] <br><br>
		Tenemos que:
	</h5>
	<img src="media/img/img10.png" alt="">
	<h5>
		<br>Lo que resulta en:
	</h5>
	<img src="media/img/img11.png" alt="">
	<h5>
		<br>Este resultado se conoce como teorema de Bayes. También se le llama fórmula para la probabilidad de las “causas”. <br>
		<br>Puesto que las Bi son una partición del espacio muestral, uno y sólo uno de los eventos Bi ocurre. (Esto es, uno de lo eventos Bi debe ocurrir y solamente uno). 
		Por lo tanto, la fórmula anterior nos da la probabilidad de un Bi particular (esto es, una “causa”), dado que el evento A ha ocurrido. Para aplicar este teorema debemos 
		conocer los valores de las P(Bi). <br>
		<br>Este teorema expone la reformulación de un conjunto de probabilidades previas (probabilidades a priori) como consecuencia de contar con información adicional 
		acerca de los eventos del fenómeno estudiado, dando origen a nuevas probabilidades denominadas probabilidades a posteriori. <br>
		<br>Supongamos que el Sr. K se somete a una prueba médica para determinar si tiene una enfermedad en particular. Esta prueba tiene limitaciones y no es perfecta. 
		Antes de la prueba, tenemos ciertas creencias iniciales sobre si el Sr. K tiene la enfermedad o no. Estas creencias se expresan como probabilidades a priori, es 
		decir, la probabilidad inicial de que el Sr. K tenga la enfermedad (P(B1)) y la probabilidad inicial de que no la tenga (P(B2)). <br><br>
		Luego, el Sr. K se somete a la prueba, y el resultado de la prueba es positivo (A = la prueba es positiva). Queremos calcular la probabilidad de que realmente 
		tenga la enfermedad, dada esta nueva evidencia, es decir, P(B1|A). <br><br>
		El Teorema de Bayes nos permite hacerlo. Para calcular P(B1|A), utilizamos la siguiente fórmula:
	</h5>
	<img src="media/img/img12.png" alt="">
	<h5>
		<br>Donde: <br>
		&emsp;&emsp;P(A|B1): Probabilidad de que la prueba sea positiva si el Sr. K tiene la enfermedad. <br>
		&emsp;&emsp;P(B1): Probabilidad a priori de que el Sr. K tenga la enfermedad. <br>
		&emsp;&emsp;P(A|B2): Probabilidad de que la prueba sea positiva si el Sr. K no tiene la enfermedad. <br>
		&emsp;&emsp;P(B2): Probabilidad a priori de que el Sr. K no tenga la enfermedad. <br>
		<br>El resultado P(B1|A) nos da la probabilidad de que el Sr. K realmente tenga la enfermedad, dado que la prueba fue positiva. Esto nos permite ajustar nuestras 
		creencias iniciales en función de la nueva evidencia. <br>
		<br><img src="media/img/doc3.gif" alt="">
		<br>De esta forma el teorema de Bayes establece cómo calcular la probabilidad de un evento, dada la probabilidad condicional de ese evento en relación con otros 
		eventos. El teorema se utiliza para invertir el orden de causa y efecto al calcular la probabilidad de un evento dado su efecto observado. [14] <br><br>
	</h5>			
</body>

</html>
